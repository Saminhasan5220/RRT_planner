from scipy.integrate import odeint
import numpy as np
import matplotlib.pyplot as plt
import math
import random

min_u2 = -1
max_u2 = 1
min_u3 = -1
max_u3 = 1

inf = np.inf

'''
    Quadrotor Dynamic model. 
    State represetned by [x1, x2, ..., x11], where: 
        x1 is the inertial (north) position, 
        x2 is the inertial (east) position, 
        x3 is the altitude, 
        x4 is the longitudinal velocity, 
        x5 is the lateral velocity, 
        x6 is the vertical velocity, 
        x7 is the roll angle, 
        x8 is the pitch angle, 
        x9 is the yaw angle, 
        x10 is the roll rate, 
        x11 is the pitch rate, 
        x12 is the yaw rate. 

    Source: https://easychair.org/publications/open/sr6
    Inputs: Xn - current state; a list
            u - a list of input
    Output: dydt
'''
def Quadrotor_Dynamic(Xn, t, u):
    # print Xn
    # obtain Vairables
    x1, x2, x9, x3, x4, x5, x6, x7, x8, x10, x11, x12 = Xn
    x1 = float(x1)
    x2 = float(x2)
    x3 = float(x3)
    x4 = float(x4)
    x5 = float(x5)
    x6 = float(x6)
    x7 = float(x7)
    x8 = float(x8)
    x9 = float(x9)
    x10 = float(x10)
    x11 = float(x11)
    x12 = float(x12)

    u1, u2, u3= u
    u1 = float(u1)
    u2 = float(u2)
    u3 = float(u3)

    # Some constants 
    # Gravity, unit(m/s^2)
    g = 9.81 
    # Radius of center mass, unit(m)
    R = 0.1
    # Distance of motors to center mass, unit(m)
    l = 0.5
    # Motor mass, unit(kg)
    Mr = 0.1
    # Center mass, unit(kg)
    M = 1
    # Total mass, unit(kg)
    Mt = M + 4*Mr

    # Moments of inertia calculated constants
    Jx = 2/5*M*R + 2*l*l*Mr
    Jy = Jx
    Jz = 2/5*M*R + 4*l*l*Mr
    
    F = Mt*g - 10*(x3-u1)+ 3*x6

    x1_dot= x4*np.cos(x8)*np.cos(x9) + x5*(np.sin(x7)*np.sin(x8)*np.cos(x9) - np.sin(x9)*np.cos(x7)) + x6*(np.sin(x7)*np.sin(x9) + np.sin(x8)*np.cos(x7)*np.cos(x9))
    x2_dot= x4*np.sin(x9)*np.cos(x8) + x5*(np.sin(x7)*np.sin(x8)*np.sin(x9) + np.cos(x7)*np.cos(x9)) + x6*(-np.sin(x7)*np.cos(x9) + np.sin(x8)*np.sin(x9)*np.cos(x7))
    x3_dot= x4*np.sin(x8) - x5*np.sin(x7)*np.cos(x8) - x6*np.cos(x7)*np.cos(x8)
    x4_dot= -x11*x6 + x12*x5 - g*np.sin(x8)
    x5_dot= x10*x6 - x12*x4 + g*np.sin(x7)*np.cos(x8)
    x6_dot= -x10*x5 + x11*x4 + g*np.cos(x7)*np.cos(x8) - F/Mt
    x7_dot= x10 + x11*np.sin(x7)*np.tan(x8) + x12*np.cos(x7)*np.tan(x8)
    x8_dot= x11*np.cos(x7) - x12*np.sin(x7)
    x9_dot= x11*np.sin(x7)/np.cos(x8) + x12*np.cos(x7)/np.cos(x8)
    x10_dot = (Jy-Jz)/Jx*x11*x12 + 1/Jx*(-(x7-u2)-x10)
    x11_dot = (Jz-Jx)/Jy*x10*x12 + 1/Jy*(-(x8-u3)-x11)
    x12_dot = (Jx-Jy)/Jz*x10*x11

    dydt = np.array([x1_dot, x2_dot, x9_dot, x3_dot, x4_dot, x5_dot, x6_dot, x7_dot, x8_dot, x10_dot, x11_dot, x12_dot])
    return dydt

'''
    randomConfig: this function generates a random point on the space Xfree
    Inputs: height - height of the screen
            width - width of the screen
    Output: a random point on the space Xfree
'''
def randomConfig(height, width):
    x = random.random()*width
    y = random.random()*height
    theta = random.random()*2*np.pi
   
    return (x, y, theta, 0, 0, 0, 0, 0, 0, 0, 0, 0)

'''
    This function uses Fourth-Order Runge-Kutta method to calculate next state.
    Inputs: Xn - current state; a list
            u - input control
    Output: Xnew - next state given current state
'''
# def newState(Xn, u):
#     # Fourth-Order Runge-Kutta method
#     k1 = Quadrotor_Dynamic(Xn, u)
#     k2 = Quadrotor_Dynamic(Xn+k1/2, u)
#     k3 = Quadrotor_Dynamic(Xn+k2/2, u)
#     k4 = Quadrotor_Dynamic(Xn+k3, u)
#     delta_t = 0.00006
#     Xnew = Xn + (k1 + 2*k2 + 2*k3 + k4)*delta_t/6
#     Xnew = list(Xnew)
#     print Xnew
#     for i in range(len(Xnew)):
#         Xnew[i] = float(Xnew[i])
#     return Xnew

'''
    This function is calculate the next state for the vehicle dynamics. 
    It tries out the input u from min_u to max_u to 
    get the best state available via newState() function. 
    Inputs: Xrand - the random state generated by randomConfig
            Xnear - the nearest state in RRT search tree to Xrand
    Output: the best next state available 
'''
def selectInput(Xrand, Xnear, obs):
    bestState = None
    bestDistance = inf

    u2 = min_u2
    
    while u2 <= max_u2:
        u3 = min_u3
        while u3 <= max_u3:
            u = [0.0, u2, u3]
            Xnew = newState(Xnear, u, 0.3)
            distance = dist(Xnew, Xrand)
            if  distance < bestDistance:
                bestState = Xnew
                bestDistance = distance
            u3 += 1
        u2 += 1   
    return bestState

'''
    This function returns the distance between two given states
    It uses Euclidean distance
'''
def dist(s1, s2):
    x1 = s1[0]
    y1 = s1[1]

    x2 = s2[0]
    y2 = s2[1]
    return np.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))

'''
    This function tries out all possible inputs at a given node Xn to 
    calculate all possible outputs

    Inputs: Xn - the state xg, yg, theta, vy, r of the Xn node
    Output: ret - all possible outcomes of Xn with all possible inputs u
'''
def tryInput(Xn):
    u2 = min_u2
    
    ret = []

    while u2 < max_u2:
        u3 = min_u3
        while u3 < max_u3:
            u = [0.0, u2, u3]
            Xnew = newState(Xn, u, 0.2)
            ret.append(Xnew)
            u3 += 1
        u2 += 1
    return ret

# -------------------------------- Simulator for test only ---------------------------------


'''
    This simulator is for test only 
    NOTE: need to add 't' argument in the above car_dynamic function to perform test
'''
def newState(initial, u, time_bound):
    time_step = 0.05
    time_bound = float(time_bound)
    initial = [float(tmp)  for tmp in initial]
    number_points = int(np.ceil(time_bound/time_step))
    t = [i*time_step for i in range(0,number_points)]
    if t[-1] != time_step:
		t.append(time_bound)

    newt = [] 
    for step in t:
        newt.append(float(format(step, '.2f')))
    t = newt
    # u = [0.0, 0.005, 0.005]
    sol = odeint(Quadrotor_Dynamic, initial, t, args=(u,), hmax=time_step)

    # Construct the final output
    trace = []
    for j in range(len(t)):
        tmp = []
        # tmp.append(t[j])
        tmp.append(float(sol[j, 0]))
        tmp.append(float(sol[j, 1]))
        tmp.append(float(sol[j, 2]))
        tmp.append(float(sol[j, 3]))
        tmp.append(float(sol[j, 4]))
        tmp.append(float(sol[j, 5]))
        tmp.append(float(sol[j, 6]))
        tmp.append(float(sol[j, 7]))
        tmp.append(float(sol[j, 8]))
        tmp.append(float(sol[j, 9]))
        tmp.append(float(sol[j, 10]))
        tmp.append(float(sol[j, 11]))
        trace.append(tmp)
    return tmp        

if __name__ == "__main__":
	sol = TC_Simulate('Default', [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 500)
        for s in sol:
            print s
        a = [row[0] for row in sol]
        b = [row[1] for row in sol]
    
        plt.plot(a, b, '-r')
        plt.show()