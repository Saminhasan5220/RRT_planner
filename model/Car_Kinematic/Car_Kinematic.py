from scipy.integrate import odeint
import numpy as np
import matplotlib.pyplot as plt
import math
import random


# Some global variabes, angle in rad
min_steer = -0.245
max_steer = 0.245

min_v_steer = -0.4
max_v_steer= 0.4
min_v = 0
max_v = 30
Vs = 7.319
max_a = 11.5


inf = np.inf

'''
    Kinematic cal model.
    State represetned by [sx, sy, psi, v, delta], where: 
        sx, sg are the location center of gravity of the car
        psi is orientation of the car
        v is the speed
        delta is the steer angle

    Inputs: Xn - current state; a list
            u - input specified as [v_delta, a]
    Output: dydt
    
'''
def Car_Kinematic(Xn, u):
    # Unpack variables
    sx, sy, psi, v, delta = Xn
    v_delta, a = u
    sx = float(sx)
    sy = float(sy)
    psi = float(psi)
    delta = float(delta)
    v = float(v)

    lwb = 2.578

    
    if delta > max_steer:
        delta = max_steer
    elif delta < min_steer:
        delta = min_steer
    
    if v > max_v:
        v = max_v
    elif v < min_v: 
        v = min_v

    sx_dot = v*np.cos(psi)
    sy_dot = v*np.sin(psi)
    delta_dot = v_delta
    v_dot = a
    psi_dot = v/lwb*np.tan(delta)

    dydt = np.array([sx_dot, sy_dot, psi_dot, v_dot, delta_dot])
    return dydt

'''
    randomConfig: this function generates a random point on the space Xfree
    Inputs: height - height of the screen
            width - width of the screen
    Output: a random configuration on the space Xfree
'''
def randomConfig(height, width):
    x = random.random()*width
    y = random.random()*height
    psi = random.random()*2*np.pi
   
    return (x, y, psi, 0, 0)

'''
    This function uses Fourth-Order Runge-Kutta method to calculate next state.
    Inputs: Xn - current state; a list
            u - input of the model 
    Output: Xnew - next state given current state
        
'''
def newState(Xn, u):
    # Fourth-Order Runge-Kutta method
    k1 = Car_Kinematic(Xn, u)
    k2 = Car_Kinematic(Xn+k1/2, u)
    k3 = Car_Kinematic(Xn+k2/2, u)
    k4 = Car_Kinematic(Xn+k3, u)
    delta_t = 0.2
    Xnew = Xn + (k1 + 2*k2 + 2*k3 + k4)*delta_t/6
    Xnew = [float(Xnew[0]), float(Xnew[1]), float(Xnew[2]), float(Xnew[3]), float(Xnew[4])]
    return Xnew


'''
    This function is calculate the next state for the vehicle dynamics. 
    It tries out the delta_f from min_steer angle to max_steer angle to 
    get the best state available via newState() function. 
    Inputs: Xrand - the random state generated by randomConfig
            Xnear - the nearest state in RRT search tree to Xrand
    Output: the best next state available 
'''
def selectInput(Xrand, Xnear, obs):
    v_delta = min_v_steer
    
    bestState = None
    bestDistance = inf
    
    while v_delta < max_v_steer:
        a = 0
        while a < max_a:
            u = [v_delta, a]
            Xnew = newState(Xnear, u)
            distance = dist(Xnew, Xrand)
            if  distance < bestDistance:
                bestState = Xnew
                bestDistance = distance
            a += 2
        v_delta += 0.1 # increment of approximately 3 degrees per iteration
            
    return bestState

'''
    This function returns the distance between two given states
    It uses Euclidean distance
'''
def dist(s1, s2):
    x1 = s1[0]
    y1 = s1[1]

    x2 = s2[0]
    y2 = s2[1]
    return np.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))

'''
    This function tries out all possible inputs at a given node Xn to 
    calculate all possible outputs

    Inputs: Xn - the state xg, yg, theta, vy, r of the Xn node
    Output: ret - all possible outcomes of Xn with all possible inputs u
'''
def tryInput(Xn):
    v_delta = min_v_steer
    a = 0
    
    ret = []
    
    while v_delta < max_v_steer:
        while a < max_a:
            u = [v_delta, a]
            Xnew = newState(Xn, u)
            ret.append(Xnew)
            a += 2
        v_delta += 0.1 # increment of approximately 3 degrees per iteration
            
    return ret


'''
    This simulator is for test only 
    NOTE: need to add 't' argument in the above Car_Dynamic function to perform test
'''
def TC_Simulate(Mode, initial, time_bound):
    time_step = 0.05
    time_bound = float(time_bound)
    initial = [float(tmp)  for tmp in initial]
    number_points = int(np.ceil(time_bound/time_step))
    t = [i*time_step for i in range(0,number_points)]
    if t[-1] != time_step:
		t.append(time_bound)

    newt = [] 
    for step in t:
        newt.append(float(format(step, '.2f')))
    t = newt
    u = [1.0, 0]
    sol = odeint(Car_Kinematic, initial, t, args=(u,), hmax=time_step)

    # Construct the final output
    trace = []
    for j in range(len(t)):
        tmp = []
        tmp.append(t[j])
        tmp.append(float(sol[j, 0]))
        tmp.append(float(sol[j, 1]))
        tmp.append(float(sol[j, 2]))
        tmp.append(float(sol[j, 3]))
        tmp.append(float(sol[j, 4]))
        trace.append(tmp)
    return trace        

if __name__ == "__main__":
	sol = TC_Simulate('Default', [5.0, 5.0, 1, 0, 0], 20)
        for s in sol:
            print s
        a = [row[1] for row in sol]
        b = [row[2] for row in sol]
    
        plt.plot(a, b, '-r')
        plt.show()

