import numpy as np
from Car_Dynamic import *
import random
from pydraw import *
from z3 import *
from checker import *
import pdb

# import pygame, sys
# from pygame.locals import *

delta_t = 0.2
min_steer = -np.pi/3
max_steer = np.pi/3
height = 500
width = 500

'''
    node class: basic element of RRT search tree
'''
class node():
    def __init__(self, state, parent):
        self.state = state
        self.parent = parent
        self.children = []
        

'''
    RRT class: the RRT planner class combined with the bicycle car model
'''
class RRT():
    
    def __init__(self, init):
        self.nodes = []
        self.Xinit = node(init, None)
        self.nodes.append(self.Xinit)

    '''
        randomConfig: this function generates a random point on the space Xfree
        Input: obs - obstacle region
        Output: a random point on the space Xfree
    '''
    def randomConfig(self, obs):
        while True:
            x = random.random()*width
            y = random.random()*height
            theta = random.random()*2*np.pi
            
            tmp = False
            for ob in obs:
                if randomChecker((x,y), ob):
                    tmp = True
            # print tmp   
            if not tmp:
                break
       
        return (x, y, theta, 0, 0)

    '''
        findNearest: find the nearest node in RRT search tree to the point Xrand 
        Input: Xrand - a random point on the space Xfree
        Output: the nearest node in RRT search tree to the point Xrand 
    '''
    def findNearest(self, Xrand):
        nn = self.nodes[0]
        for p in self.nodes:
            if self.dist(p.state, Xrand) < self.dist(nn.state, Xrand):
                nn = p
        return nn

    '''
        This function uses Fourth-Order Runge-Kutta method to calculate next state.
        Inputs: Xn - current state; a list
                delta_f - steering angle of the car 
        Output: Xnew - next state given current state
        
    '''
    def newState(self, Xn, delta_f):
        # Fourth-Order Runge-Kutta method
        k1 = car_dynamic(Xn, delta_f)
        k2 = car_dynamic(Xn+k1/2, delta_f)
        k3 = car_dynamic(Xn+k2/2, delta_f)
        k4 = car_dynamic(Xn+k3, delta_f)

        Xnew = Xn + (k1 + 2*k2 + 2*k3 + k4)*delta_t/6
        return Xnew

    '''
        This function is calculate the next state for the vehicle dynamics. 
        It tries out the delta_f from min_steer angle to max_steer angle to 
        get the best state available via newState() function. 
        Inputs: Xrand - the random state generated by randomConfig
                Xnear - the nearest state in RRT search tree to Xrand
        Output: the best next state available 
    '''
    def selectInput(self, Xrand, Xnear):
        delta_f = min_steer
        bestState = self.newState(Xnear, delta_f)
        bestDistance = float(self.dist(bestState, Xrand))
        
        # Loop delta_f from min_steer angle to max_steer 
        while delta_f < max_steer:
            Xnew = self.newState(Xnear, delta_f)
            distance = self.dist(Xnew, Xrand)
            if  distance < bestDistance:
                bestState = Xnew
                bestDistance = distance
            delta_f += np.pi/60 # increment of approximately 3 degrees per iteration
        
        return bestState

    '''
        This function returns a path from Xinit to Xnew
        Inputs: Xnew - the endpoint of the path we want to calculate
        Output: a path from Xinit to Xnew
    '''
    def getPath(self, Xnew):
        node = Xnew
        path = []
        path.append(node)
        while(node != self.Xinit):
            node = node.parent
            path.append(node)
        path.reverse()
        return path
   
    '''
        This function is the RRT planner. It uses a modified RRT algorithm to 
        find the path from Xinit to Xgoal region. 

        Inputs: K - total number of nodes/iterations allowed
                goal - goal region
                p - try_goal_probability; the probability that Xgoal is picked as Xrand
                obs - obstacle region Xobs
                flag - a flag that indicates if a critical point Xcritic is found; found 1/not 0
                screen - the pygame screen for printing the game status

        Output: the path from Xinit to Xgoal

        NOTE: Xcritic is set at point where it may directly connect to Xgoal
    '''
    def plan(self, K, goal, p, obs, flag, screen):
        if p > 1 or p < 0:
            print "invalid p"
            return None

        for i in range(K):
            # Find Xrand
            if random.random() < p:
                Xrand = ((goal[1]+goal[0])/2, (goal[3]+goal[2])/2, random.random()*2*np.pi, 0, 0)
            else:
                Xrand = self.randomConfig(obs)

            # Pick Xnear
            Xnear = self.findNearest(Xrand)
            # print Xnear.state
            
            # Calculate new state from using Xrand and Xnear
            u = self.selectInput(Xrand, Xnear.state)
            Xnew = node(u, Xnear)
            p1 = (int(Xnear.state[0]), int(Xnear.state[1]))
            p2 = (int(Xnew.state[0]), int(Xnew.state[1]))
            # Check if connecting to Xnew will collide with obstacles
            collision = collisionCheck(p1, p2, obs)

            # See if Xnew can be connected directly to the goal region
            if connectChecker(Xnew.state, goal, obs) and flag != 1 and (not collision):
                # If so, set Xnew as new state
                print 'critic find'
                print 'subStart', Xnew.state
                subStart = (Xnew.state[0],Xnew.state[1], Xnew.state[2], Xnew.state[3], Xnew.state[4])
                G_prime = RRT(subStart)
                p = 0.7
                subpath = G_prime.plan(K-i, goal, p, obs, 1, screen)
                if subpath != None:
                    print 'goal find'
                    path = self.getPath(Xnew)
                    return path+subpath
                
            # If no intersections with obstacles, add Xnew to the tree and upate the graph
            if not collision:
                self.nodes.append(Xnew)
                Xnear.children.append(Xnew)
                drawScreen(screen, p1, p2, goal, obs)
            # Else, delete a few nodes on the branch
            else:
                print "clean"
                self.collisionClean(Xnew)
            
            if goalCheck(Xnew.state, goal):
                return self.getPath(Xnew)
        
        return None
        

    # Helper Functions
    '''
        This function returns the distance between two given states
    '''
    def dist(self, s1, s2):
        x1 = s1[0]
        y1 = s1[1]
        theta1 = s1[2]

        x2 = s2[0]
        y2 = s2[1]
        theta2 = s2[2]

        theta_diff = abs(theta1 - theta2)
        
        theta_diff = min(theta_diff, 2*np.pi - theta_diff)
        return np.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + theta_diff*theta_diff)

    '''
        This functions cleans the some nodes in self.nodes when collision happens
        The reason to do this is because once a collision happens, 
        this tree branch will be useless
    '''
    def collisionClean(self, Xnew):
        n = Xnew.parent
        while True:
            if n == self.Xinit:
                break
            if len(n.children) >= 2:
                break
            self.nodes.remove(n)
            n = n.parent


