import numpy as np
from Car_Dynamic import *
import random
from pydraw import *
from z3 import *
from checker import *
import pdb
from math import atan
import time

# import pygame, sys
# from pygame.locals import *

delta_t = 0.2
min_steer = -np.pi/6
max_steer = np.pi/6
height = 500
width = 500

'''
    node class: basic element of RRT search tree
'''
class node():
    def __init__(self, state, parent, delta_f):
        self.state = state
        self.parent = parent
        self.children = []
        self.input = delta_f
        

'''
    RRT class: the RRT planner class combined with the bicycle car model
'''
class RRT():
    
    def __init__(self, init):
        self.nodes = []
        self.Xinit = node(init, None, None)
        self.nodes.append(self.Xinit)
        self.Xnear = node(None, None, None)

    '''
        randomConfig: this function generates a random point on the space Xfree
        Input: obs - obstacle region
        Output: a random point on the space Xfree
    '''
    def randomConfig(self, obs):
        x = random.random()*width
        y = random.random()*height
        theta = random.random()*2*np.pi
       
        return (x, y, theta, 0, 0)

    '''
        findNearest: find the nearest node in RRT search tree to the point Xrand 
        Input: Xrand - a random point on the space Xfree
        Output: the nearest node in RRT search tree to the point Xrand 
    '''
    def findNearest(self, Xrand):
        if self.Xnear != self.nodes[0]:
            nn = self.nodes[0]
        else:
            nn = self.nodes[1]
        for p in self.nodes:
            if p == self.Xnear:
                continue
            if self.dist(p.state, Xrand) < self.dist(nn.state, Xrand):
                nn = p
        return nn

    '''
        This function uses Fourth-Order Runge-Kutta method to calculate next state.
        Inputs: Xn - current state; a list
                delta_f - steering angle of the car 
        Output: Xnew - next state given current state
        
    '''
    def newState(self, Xn, delta_f):
        # Fourth-Order Runge-Kutta method
        k1 = car_dynamic(Xn, delta_f)
        k2 = car_dynamic(Xn+k1/2, delta_f)
        k3 = car_dynamic(Xn+k2/2, delta_f)
        k4 = car_dynamic(Xn+k3, delta_f)

        Xnew = Xn + (k1 + 2*k2 + 2*k3 + k4)*delta_t/6
        return Xnew

    '''
        This function is calculate the next state for the vehicle dynamics. 
        It tries out the delta_f from min_steer angle to max_steer angle to 
        get the best state available via newState() function. 
        Inputs: Xrand - the random state generated by randomConfig
                Xnear - the nearest state in RRT search tree to Xrand
        Output: the best next state available 
    '''
    def selectInput(self, Xrand, Xnear):
        delta_f = min_steer
        bestDelta = delta_f
        bestState = self.newState(Xnear, delta_f)
        bestDistance = float(self.dist(bestState, Xrand))
        
        # Loop delta_f from min_steer angle to max_steer 
        while delta_f < max_steer:
            Xnew = self.newState(Xnear, delta_f)
            distance = self.dist(Xnew, Xrand)
            if  distance < bestDistance:
                bestDelta = delta_f
                bestState = Xnew
                bestDistance = distance
            delta_f += np.pi/60 # increment of approximately 3 degrees per iteration
        
        return bestState, bestDelta

    '''
        This function returns a path from Xinit to Xnew
        Inputs: Xnew - the endpoint of the path we want to calculate
        Output: a path from Xinit to Xnew
    '''
    def getPath(self, Xnew):
        node = Xnew
        path = []
        path.append(node.state)
        while(node != self.Xinit):
            node = node.parent
            path.append(node.state)
        path.reverse()
        return path
   
    '''
        This function is the RRT planner. It uses a modified RRT algorithm to 
        find the path from Xinit to Xgoal region. 

        Inputs: K - total number of nodes/iterations allowed
                goal - goal region
                p - try_goal_probability; the probability that Xgoal is picked as Xrand
                obs - obstacle region Xobs
                flag - a flag that indicates if a critical point Xcritic is found; found 1/not 0
                screen - the pygame screen for printing the game status

        Output: the path from Xinit to Xgoal

        NOTE: Xcritic is set at point where it may directly connect to Xgoal
    '''
    def plan(self, K, goal, p, obs, flag, screen):
        
        if p > 1 or p < 0:
            print "invalid p"
            return None

        for i in range(K):
            print i, 'th iteration'
            # Find Xrand
            if random.random() < p:
                Xrand = ((goal[1]+goal[0])/2, (goal[3]+goal[2])/2, random.random()*2*np.pi, 0, 0)
            else:
                Xrand = self.randomConfig(obs)

            # Pick Xnear
            # prevXnear = self.Xnear
            # pdb.set_trace()
            self.Xnear = self.findNearest(Xrand)
            # print self.Xnear.state
           
            # Calculate new state from using Xrand and Xnear
            u, delta_f = self.selectInput(Xrand, self.Xnear.state)
            Xnew = node(u, self.Xnear, delta_f)
            p1 = (int(self.Xnear.state[0]), int(self.Xnear.state[1]))
            p2 = (int(Xnew.state[0]), int(Xnew.state[1]))
            # Check if connecting to Xnew will collide with obstacles
            collision = collisionCheck(p1, p2, obs)

            # See if Xnew can be connected directly to the goal region
            # if connectChecker(Xnew.state, goal, obs) and flag != 1 and (not collision):
            #     # If so, set Xnew as new state
            #     print 'critic find'
            #     print 'subStart', Xnew.state
            #     G_prime = RRT(Xnew.state)
            #     p = 0.9
            #     subpath = G_prime.plan(K-i, goal, p, obs, 1, screen)
            #     if subpath != None:
            #         print 'goal find'
            #         path = self.getPath(Xnew)
            #         return path+subpath
                
            # If no intersections with obstacles, add Xnew to the tree and upate the graph
            if not collision:
                self.nodes.append(Xnew)
                self.Xnear.children.append(Xnew)
                drawScreen(screen, p1, p2, goal, obs)
            # Else, delete a few nodes on the branch
            else:
                print "clean"
                delta_list, X_0 = self.collisionClean(Xnew)
                print delta_list
            
            if goalCheck(Xnew.state, goal):
                return self.getPath(Xnew)
        
        return None
        

    # Helper Functions
    '''
        This function returns the distance between two given states
    '''
    def dist(self, s1, s2):
        x1 = s1[0]
        y1 = s1[1]
        theta1 = s1[2]

        x2 = s2[0]
        y2 = s2[1]
        theta2 = atan((y2-y1)/(x2-x1))

        theta_diff = abs(theta1 - theta2)

        theta_diff = min(theta_diff, 2*np.pi - theta_diff)
        # print 'dist ', (x1-x2)*(x1-x2), (y1-y2)*(y1-y2), theta_diff*theta_diff
        return np.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))

    '''
        This functions discard some nodes in self.nodes when collision happens
        The reason to do this is because once a collision happens, 
        this tree branch will be useless
    '''
    def collisionClean(self, Xnew):
        n = Xnew.parent
        delta_list = []
        while True:
            if n == self.Xinit:
                break
            if len(n.children) >= 2:
                break
            # self.nodes.remove(n)
            delta_list.append(n.input)
            n = n.parent

        delta_list.reverse()
        return delta_list, n

