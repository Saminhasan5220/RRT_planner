import numpy as np
from Car_Dynamic import *
import random
from pydraw import *
from z3 import *
from checker import *
import pdb
from math import atan, ceil
import time
from operator import itemgetter


delta_t = 0.2
min_steer = -np.pi/6
max_steer = np.pi/6
width = 500
height = 500


'''
    node class: basic element of RRT search tree
'''
class node():
    def __init__(self, state, parent):
        self.state = state
        self.parent = parent
        self.children = []
        

'''
    RRT class: the RRT planner class combined with the bicycle car model
'''
class RRT():
    
    def __init__(self, init):
        self.nodes = []
        self.Xinit = node(init, None)
        self.nodes.append(self.Xinit)
        self.Xnear = node(None, None)

    '''
        randomConfig: this function generates a random point on the space Xfree
        Input: obs - obstacle region
        Output: a random point on the space Xfree
    '''
    def randomConfig(self, obs):
        x = random.random()*width
        y = random.random()*height
        theta = random.random()*2*np.pi
       
        return (x, y, theta, 0, 0)

    '''
        findNearest: find the nearest node in RRT search tree to the point Xrand 
        Input: Xrand - a random point on the space Xfree
        Output: the nearest node in RRT search tree to the point Xrand 
    '''
    def findNearest(self, Xrand):
        if self.Xnear != self.nodes[0]:
            nn = self.nodes[0]
        else:
            nn = self.nodes[1]
        for p in self.nodes:
            if p == self.Xnear:
                continue
            if self.dist(p.state, Xrand) < self.dist(nn.state, Xrand):
                nn = p
        return nn

    '''
        This function uses Fourth-Order Runge-Kutta method to calculate next state.
        Inputs: Xn - current state; a list
                delta_f - steering angle of the car 
        Output: Xnew - next state given current state
        
    '''
    def newState(self, Xn, delta_f):
        # Fourth-Order Runge-Kutta method
        k1 = car_dynamic(Xn, delta_f)
        k2 = car_dynamic(Xn+k1/2, delta_f)
        k3 = car_dynamic(Xn+k2/2, delta_f)
        k4 = car_dynamic(Xn+k3, delta_f)

        Xnew = Xn + (k1 + 2*k2 + 2*k3 + k4)*delta_t/6
        Xnew = [float(Xnew[0]), float(Xnew[1]), float(Xnew[2]), float(Xnew[3]), float(Xnew[4])]
        return Xnew

    '''
        This function is calculate the next state for the vehicle dynamics. 
        It tries out the delta_f from min_steer angle to max_steer angle to 
        get the best state available via newState() function. 
        Inputs: Xrand - the random state generated by randomConfig
                Xnear - the nearest state in RRT search tree to Xrand
        Output: the best next state available 
    '''
    def selectInput(self, Xrand, Xnear):
        delta_f = min_steer
        bestState = self.newState(Xnear, delta_f)
        bestDistance = float(self.dist(bestState, Xrand))
        
        # Loop delta_f from min_steer angle to max_steer 
        while delta_f < max_steer:
            Xnew = self.newState(Xnear, delta_f)
            distance = self.dist(Xnew, Xrand)
            if  distance < bestDistance:
                bestState = Xnew
                bestDistance = distance
            delta_f += np.pi/60 # increment of approximately 3 degrees per iteration
        
        return bestState

    '''
        This function returns a path from Xinit to Xnew
        Inputs: Xnew - the endpoint of the path we want to calculate
        Output: a path from Xinit to Xnew
    '''
    def getPath(self, Xnew):
        node = Xnew
        path = []
        path.append(node.state)
        while(node != self.Xinit):
            node = node.parent
            path.append(node.state)
        path.reverse()
        return path
   
    '''
        This function is the RRT planner. It uses a modified RRT algorithm to 
        find the path from Xinit to Xgoal region. 

        Inputs: K - total number of nodes/iterations allowed
                goal - goal region
                p - try_goal_probability; the probability that Xgoal is picked as Xrand
                obs - obstacle region Xobs
                flag - a flag that indicates if we turn on dynamic goal bias (DISCARDED)
                screen - the pygame screen for printing the game status

        Output: the path from Xinit to Xgoal

        NOTE: Xcritic is set at point where it may directly connect to Xgoal
    '''
    def plan(self, K, goal, p, obs, flag, screen):
        
        if p > 1 or p < 0:
            print "invalid p"
            return None

        for i in range(K):
            print i, 'th iteration'
            # Find Xrand
            if random.random() < p:
                Xrand = ((goal[1]+goal[0])/2, (goal[3]+goal[2])/2, random.random()*2*np.pi, 0, 0)
            else:
                Xrand = self.randomConfig(obs)

            # Pick Xnear
            # pdb.set_trace()
            self.Xnear = self.findNearest(Xrand)
            print self.Xnear.state
           
            # Calculate new state from using Xrand and Xnear
            u = self.selectInput(Xrand, self.Xnear.state)
            Xnew = node(u, self.Xnear)
            p1 = (int(self.Xnear.state[0]), int(self.Xnear.state[1]))
            p2 = (int(Xnew.state[0]), int(Xnew.state[1]))
            # Check if connecting to Xnew will collide with obstacles
            collision = collisionCheck(p1, p2, obs)

            # See if Xnew can be connected directly to the goal region
            # if connectChecker(Xnew.state, goal, obs) and flag != 1 and (not collision):
            #     # If so, set Xnew as new state
            #     print 'critic find'
            #     print 'subStart', Xnew.state
            #     G_prime = RRT(Xnew.state)
            #     p = 0.9
            #     subpath = G_prime.plan(K-i, goal, p, obs, 1, screen)
            #     if subpath != None:
            #         print 'goal find'
            #         path = self.getPath(Xnew)
            #         return path+subpath
                
            # If no intersections with obstacles, add Xnew to the tree and upate the graph
            if not collision:
                self.nodes.append(Xnew)
                self.Xnear.children.append(Xnew)
                drawScreen(screen, p1, p2, goal, obs)
            # Else, delete a few nodes on the branch
            else:
                print "collide"
                # self.collisionClean(Xnew)
                X_array = self.collisionClean(Xnew)
                epsilon = 2
                epsilon_array = self.branchElim(X_array, epsilon)
                return X_array, epsilon_array
            
            if goalCheck(Xnew.state, goal):
                return self.getPath(Xnew)
        
        return None
        

    # Helper Functions
    '''
        This function returns the distance between two given states
    '''
    def dist(self, s1, s2):
        x1 = s1[0]
        y1 = s1[1]
        theta1 = s1[2]

        x2 = s2[0]
        y2 = s2[1]
        theta2 = atan((y2-y1)/(x2-x1))

        theta_diff = abs(theta1 - theta2)

        theta_diff = min(theta_diff, 2*np.pi - theta_diff)
        return np.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))

    '''
        OLD: 
        This functions discard some nodes in self.nodes when collision happens
        The reason to do this is because once a collision happens, 
        this tree branch will be useless

        NEW: 
        This function returns an array contains nodes on the branch that collides 
        with obstacles. 
    '''
    def collisionClean(self, Xnew):
        # n = Xnew.parent
        # while True:
        #     if n == self.Xinit:
        #         break
        #     if len(n.children) >= 2:
        #         break
        #     self.nodes.remove(n)
        #     n = n.parent
        
        x = Xnew.parent
        X_array = []
        for i in range(8):
            if x == self.Xinit:
                break
            X_array.append(x)
            if len(x.children) >= 2:
                break
            x = x.parent
        X_array.reverse()
        return X_array
        

    def branchElim(self, X_array, epsilon):
        X0 = X_array[0]
        X0_array = []
        epsilon_array = []
        epsilon_array.append(epsilon)
        for i in range(16):
            if i == 0:
                # x = X0.state[0]
                # y = X0.state[1]
                x, y, theta, vy, r = X0.state
            else:
                x = random.randint(int(X0.state[0])-epsilon, int(X0.state[0])+epsilon)
                y = random.randint(int(X0.state[1])-epsilon, int(X0.state[1])+epsilon)
                theta = random.randint(int(X0.state[2])-epsilon, int(X0.state[2])+epsilon)
                vy = random.randint(int(X0.state[3])-epsilon, int(X0.state[3])+epsilon)
                r = random.randint(int(X0.state[4])-epsilon, int(X0.state[4])+epsilon)
            Xn = [x, y, theta, vy, r]
            X0_array.append(Xn)
            epsilon_prime = epsilon
        
        for i in range(len(X_array)):
            lt, rt, lb, rb = self.getExtreme(X0, epsilon_prime)
            X0_array.append(lt)
            X0_array.append(rt)
            X0_array.append(lb)
            X0_array.append(rb)
            X0_array.reverse()
            epsilon_prime, X1_array = self.elimination(X0_array[:20], epsilon_prime)
            epsilon_prime = int(epsilon_prime)
            epsilon_array.append(epsilon_prime)
            X0_array = X1_array
            random.shuffle(X0_array)

        return epsilon_array

    def elimination(self, X0_array, epsilon):
        X1_array = []
        for Xn in X0_array:
            # print Xn
            output = self.tryInput(Xn)
            X1_array = X1_array + output
            # print len(X1_array)

        X1_array = sorted(X1_array, key=itemgetter(1))
        h = X1_array[-1][1] - X1_array[0][1]
        X1_array = sorted(X1_array, key=itemgetter(0))
        w = X1_array[-1][0] - X1_array[0][0]

        epsilon_prime = ceil((h+w)/2)/2
        return epsilon_prime, X1_array
        
    def tryInput(self, Xn):
        delta_f = min_steer
        ret = []
        # Loop delta_f from min_steer angle to max_steer 
        while delta_f < max_steer:
            Xnew = self.newState(Xn, delta_f)
            delta_f += np.pi/60 # increment of approximately 3 degrees per iteration
            ret.append(Xnew)
        return ret
    
    def getExtreme(self, X0, epsilon):
        x, y, theta, vy, r = X0.state

        x1 = x - epsilon
        y1 = y - epsilon
        theta1 = random.randint(int(X0.state[2])-epsilon, int(X0.state[2])+epsilon)
        vy1 = random.randint(int(X0.state[3])-epsilon, int(X0.state[3])+epsilon)
        r1 = random.randint(int(X0.state[4])-epsilon, int(X0.state[4])+epsilon)

        lt = (x1, y1, theta1, vy1, r1)

        x2 = x + epsilon
        y2 = y - epsilon
        theta2 = random.randint(int(X0.state[2])-epsilon, int(X0.state[2])+epsilon)
        vy2 = random.randint(int(X0.state[3])-epsilon, int(X0.state[3])+epsilon)
        r2 = random.randint(int(X0.state[4])-epsilon, int(X0.state[4])+epsilon)
        
        rt = (x2, y2, theta2, vy2, r2)

        x3 = x - epsilon
        y3 = y + epsilon
        theta3 = random.randint(int(X0.state[2])-epsilon, int(X0.state[2])+epsilon)
        vy3 = random.randint(int(X0.state[3])-epsilon, int(X0.state[3])+epsilon)
        r3 = random.randint(int(X0.state[4])-epsilon, int(X0.state[4])+epsilon)

        lb = (x3, y3, theta3, vy3, r3)

        x4 = x + epsilon
        y4 = y + epsilon
        theta4 = random.randint(int(X0.state[2])-epsilon, int(X0.state[2])+epsilon)
        vy4 = random.randint(int(X0.state[3])-epsilon, int(X0.state[3])+epsilon)
        r4 = random.randint(int(X0.state[4])-epsilon, int(X0.state[4])+epsilon)

        rb = (x4, y4, theta4, vy4, r4)
        return lt, rt, lb, rb

if __name__ == '__main__': 
    G = RRT([370, 200, 6.0, 0.0, 0.0])
    X = node([370, 200, 6.0, 0.0, 0.0], None)
    print G.elimination(X, 10)